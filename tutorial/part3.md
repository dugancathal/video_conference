# Test-Driven WebRTC with AngularJS

## Signaling, Continued

Last time, we got a signaler in place so we can send all the appropriate information
between clients. To break down what messages we need to send, we need to look at
some of the RTC things going on under the covers.

To start, when a client enters the room, they have to let everyone else know they've
entered. I've heard this called an "Announcement", which as good of a name as any,
so that's what we'll call it here.


After receiving an `Announcement`, one (and exactly one) client must create an `RTCPeerConnection`.

This connection object can create an offer using the `createOffer` method and
send that to the other peer (`OfferDescriptionMessage`). The peer must send an
answer (created using `createAnswer` - `AnswerDescriptionMessage`), and a session
begins.

The last kind of message we have to worry about is for ICE (Interactive Connectivity
Establishment). Though RTC abstracts the vast majority of ICE for us, it's so big
I've got a whole post devoted to it (take a look at part4). We'll call this message
the `IceCandidateMessage`.

For the visual learners, here's a picture.

![RTC Sequence Diagram](rtc_sequence_diagram.png "RTC Sequence Diagram")

There are several things missing from this diagram, including ICE messages. However,
it covers all the parts of RTC that we have explicit control over. The timing for
the rest of the interactions are all managed with callbacks - things like
`onicecandidate`, `onaddstream`, etc.

## The Code

Now, the OfferDescription and AnswerDescription messages are going to be handled
purely by WebRTC. We're going to call the `createX` method on our `PeerConnection`,
then stuff the value we get back down the pipe to our peers. _PeerConnection is
just a thin wrapper over `RTCPeerConnection`. We'll come back to it._

For brevity's sake, I've omitted most of the specs for this; take a gander at the
repo if you need the full thing.

```javascript
// spec/javascripts/peer_connector_spec.js
describe('PeerConnector', function () {
  // setup tests ...
  // $provide a fake PeerConnection object that just returns promises.
  describe('.createOffer', function () {
    it('sends the offer to the designated peer and sets the local description', inject(function (PeerConnector, Signaler) {
      spyOn(Signaler, 'sendToPeer').and.callThrough();
      spyOn(peerConnection, 'setLocalDescription').and.callThrough();

      PeerConnector.createOffer(42);

      createOfferDeferred.resolve({my: 'data'});
      $scope.$digest();

      expect(Signaler, 'sendToPeer').toHaveBeenCalledWith(42, {description: {my: 'data'}});
      expect(peerConnection.setLocalDescription).toHaveBeenCalledWith({my: 'data'});
    }));
  });
  // ...
});
```

And the implementation ...

```javascript
// lib/video_conference/public/javascripts/peer_connector.js
angular.module('video_conference').service('PeerConnector', ['PeerConnection', 'Signaler'
  function (PeerConnection, Signaler) {
    return {
      createOffer: function createOffer(peerId) {
        var peerConnection = new PeerConnection({/* some kind of RTC config */});

        peerConnection.createOffer().then(function (offer) {
          peerConnection.setLocalDescription(offer, /* successCallback */, /* failureCallback */);
          Signaler.sendToPeer(peerId, {description: descr})
        });
      }
    };
  }
]);
```

And we have something very similar to this for `createAnswer`. The primary difference
being that `createAnswer` will `setRemoteDescription` first with the received
description, and then `setLocalDescription` with the answer. _Hurray callback soup!_

The other message type we need to worry about is the `IceCandidateMessage`. These
are generated by the `PeerConnection` itself through the `onicecandidate` callback.

```javascript
// spec/javascripts/peer_connection_spec.js
describe('PeerConnection', function () {
  // ... pretty standard preamble, except for ...
  // fakePC = jasmine.createSpyObj('RTCPeerConnection', ['onicecandidate']);
  // spyOn(window, 'RTCPeerConnection').and.returnValue(fakePC);

  describe('onicecandidate', inject(function (PeerConnection, Signaler) {
    it('sends valid candidates to its peer', function () {
      var pc = new PeerConnection({config: 'data'});
      spyOn(Signaler, 'sendToPeer');
      pc.onicecandidate({candidate: {sdpMLineIndex: 4, sdpMid: 3, candidate: 'some long sdp'}});

      expect(Signaler.sendToPeer).toHaveBeenCalledWith({
        id: 3,
        label: 4,
        candidate: 'some long sdp'
      });
    });
  }));
});
```

```javascript
// lib/video_conference/public/javascripts/peer_connection.js
angular.module('video_conference').factory('PeerConnection', ['Signaler',
  function (Signaler) {
    return function (config, peerId) {
      this.connection = new RTCPeerConnection(config);
      // ...
      this.connection.onicecandidate = function (event) {
        if(!event.candidate) { return; }
        Signaler.sendToPeer(peerId, {
          id: event.candidate.sdpMid,
          label: event.candidate.sdpMLineIndex,
          candidate: event.candidate.candidate
        });
      };
      // ...
    };
  }
]);
```

So here we assert on the content of IceCandidateMessage and ensure that we're
returning all the pieces we need for RTC to do its job.

#### A quick aside about `PeerConnection`

The PeerConnection object is an interesting one - one _could_ leave it completely out of this architecture and be perfectly okay. I'm wrapping
`RTCPeerConnection` for two very important reasons:

1. I prefer dealing with promises over dealing with callbacks, and all of the
  `RTCPeerConnection` API is written in callbacks. Promises are easier to test
  in my opinion and they make for cleaner code.
2. I prefer mocking my own "library" in my PeerConnector tests and keeping the
  logic in those tests concerned with APIs that I've built and not what WebRTC
  has mandated.

### The Message Objects

Up till now, we've been looking at everything from the message _sender's_ point of
view. It's now time to make things happen for the receiver.

As I'm traditionally a Ruby developer and a huge fan of the [Command Pattern](http://en.wikipedia.org/wiki/Command_pattern),
I went down the path of messages as dynamically-created command objects. This is
one of those instances where a little meta-programming is gonna save us some code.

First, we'll go back to the sending of all of our sent messages and add a `type`
property. This will allow us to create the correct message types as the receiver.

Then we can add a static method on our Message factory that does the decoding for
us.

```javascript
// spec/javascripts/message_spec.js
describe('Message', function () {
  describe('Message.build', function () {
    var FakeMessage, Message;

    beforeEach(function () {
      module('video_conference', function ($provide) {
        FakeMessage = function FakeMessage() {};
        $provide.value('FakeMessage', FakeMessage)
      });

      inject(function (_Message_) {
        Message = _Message_;
      });
    });

    it('returns a message of the given type', function () {
      var m = Message.build({type: 'FakeMessage'});
      expect(m).toEqual(jasmine.any(FakeMessage));
    });

    it('ignores unknown message types', function () {
      var m = Message.build({type: 'Unknown'});
      expect(m).toBeUndefined();
    });
  });
});
```


After we inject the `$injector` service (and look at the Angular docs for a few minutes),
the implementation is straightforward. Note the inclusion of a `SAFE_MESSAGES` list
to only let known message types through.

```javascript
// lib/video_conference/public/javascripts/messages.js
Message.build = function (data) {
  if(SAFE_MESSAGES.indexOf(data.type) === -1) { return; }
  try {
    return new ($injector.get(data.type))(data);
  } catch(e) {};
};
```

Now, in our Signaler, we make onMessage instantiate the right kind of message upon
receipt.

```javascript
// spec/javascripts/signaler_spec.js
describe('onMessage', function () {
  it('instantiates the message type', function () {
    spyOn(Message, 'build');

    var onMessage;
    spyOn(Channel, 'subscribe').and.callFake(function (callback) {
      onMessage = callback;
    });

    Signaler.init('/my-room');

    onMessage.call(this, {type: 'IceCandidateMessage', message: 'content'});
    expect(Message.build).toHaveBeenCalledWith({type: 'IceCandidateMessage', message: 'content'});
  });
});
```

In order for this to work, we have to create the Message "subtypes". Each of these
will, for now, be just an initializer.

```javascript
// lib/video_conference/public/javascripts/channel.js
init: function (roomName) {
  Channel.init(FAYE_URL, roomName);
  return Channel.subscribe(function (message) {
    return Message.build(message);
  });
},
```

And with that, we've got a Signaling framework in place.

## Up Next


Now that we've got the sender working properly (mostly), the receiver needs some love.
Keep an eye out for next time when we talk about ICE and PeerConnections more in depth.
